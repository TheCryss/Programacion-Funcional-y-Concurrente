import  Newton._
val test1= Resta(Suma(Numero(1),Numero(0)),Prod(Numero(1),Suma(Atomo('x'),Numero(0))))
val test2= Div(Suma(Atomo( 'y' ) , Numero ( 2 ) ), Suma(Atomo( 'y' ) , Numero ( 2 ) ))
val test3= Prod(Numero(3),Atomo('x'))
val test4= Expo (Atomo( 'x' ) , Numero ( 3 ) )
val test5= Logaritmo (Atomo( 'x' ) )
val test6 = Resta(Atomo('x'),Atomo('y'))
val test7 = Expo(Atomo('x'),Atomo('x'))

mostrar(test1)
mostrar(test2)
mostrar(test3)
mostrar(test4)
mostrar(test5)
mostrar(test6)

mostrar(derivar(test1,Atomo('x')))
mostrar(derivar(test2,Atomo('y')))
mostrar(derivar(test3,Atomo('x')))
mostrar(derivar(test4,Atomo('x')))
mostrar(derivar(test5,Atomo('x')))
mostrar(derivar(test6,Atomo('y')))
/*
mostrar(limpiar(derivar(test1,Atomo('x'))))
mostrar(limpiar(test2))
mostrar(limpiar(derivar(test3,Atomo('x'))))
mostrar(limpiar(derivar(test4,Atomo('x'))))
mostrar(limpiar(derivar(test5,Atomo('x'))))
mostrar(limpiar(derivar(test6,Atomo('y'))))
*/
evaluar(test1,Atomo('x'),2)
evaluar(test2,Atomo('x'),3)
evaluar(test3,Atomo('x'),0)
evaluar(test4,Atomo('x'),-2)
evaluar(test5,Atomo('x'),1)
evaluar(test6,Atomo('y'),3)

def buenaAprox ( f : Expr , a : Atomo , d : Double ) : Boolean = {evaluar ( f , a , d ) < 0.001}
raizNewton(test1,Atomo('x'),1,buenaAprox)
raizNewton(test7,Atomo('y'),2,buenaAprox)
raizNewton(test3,Atomo('x'),1,buenaAprox)
raizNewton(test4,Atomo('x'),1,buenaAprox)
raizNewton(test5,Atomo('x'),1,buenaAprox)
